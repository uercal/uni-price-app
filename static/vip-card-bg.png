ks must have at least one argument",
    },
    "callAsyncMultipleAsyncLateErrorEarlyResult2": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleAsyncWithArg": Object {
      "type": "async",
      "value": 45,
    },
    "callAsyncMultipleAsyncWithArgCalled1": 42,
    "callAsyncMultipleAsyncWithArgCalled2": 43,
    "callAsyncMultipleAsyncWithArgFirstReturn": Object {
      "type": "async",
      "value": 43,
    },
    "callAsyncMultipleAsyncWithArgFirstReturnCalled1": 42,
    "callAsyncMultipleAsyncWithArgFirstReturnCalled2": 43,
    "callAsyncMultipleAsyncWithArgLastReturn": Object {
      "type": "async",
      "value": 44,
    },
    "callAsyncMultipleAsyncWithArgLastReturnCalled1": 42,
    "callAsyncMultipleAsyncWithArgLastReturnCalled2": 42,
    "callAsyncMultipleAsyncWithArgNoReturn": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncMultipleAsyncWithArgNoReturnCalled1": 42,
    "callAsyncMultipleAsyncWithArgNoReturnCalled2": 42,
    "callAsyncMultipleMixed1WithArg": Object {
      "type": "async",
      "value": 48,
    },
    "callAsyncMultipleMixed1WithArgCalled1": 42,
    "callAsyncMultipleMixed1WithArgCalled2": 43,
    "callAsyncMultipleMixed1WithArgCalled3": 45,
    "callAsyncMultipleMixed2WithArg": Object {
      "type": "async",
      "value": 45,
    },
    "callAsyncMultipleMixed2WithArgCalled1": 42,
    "callAsyncMultipleMixed2WithArgCalled2": 43,
    "callAsyncMultipleMixed3WithArg": Object {
      "type": "async",
      "value": 48,
    },
    "callAsyncMultipleMixed3WithArgCalled1": 42,
    "callAsyncMultipleMixed3WithArgCalled2": 43,
    "callAsyncMultipleMixed3WithArgCalled3": 45,
    "callAsyncMultipleMixedError1WithArg": Object {
      "error": "Error in sync",
      "type": "async",
    },
    "callAsyncMultipleMixedError1WithArgCalled1": 42,
    "callAsyncMultipleMixedError1WithArgCalled2": 42,
    "callAsyncMultipleMixedError1WithArgCalled3": 43,
    "callAsyncMultipleMixedError2WithArg": Object {
      "error": "Error in promise",
      "type": "async",
    },
    "callAsyncMultipleMixedError2WithArgCalled1": 42,
    "callAsyncMultipleMixedError2WithArgCalled2": 42,
    "callAsyncMultipleMixedError3WithArg": Object {
      "error": "Error in async",
      "type": "async",
    },
    "callAsyncMultipleMixedError3WithArgCalled1": 42,
    "callAsyncMultipleMixedLateError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultiplePromiseEarlyError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultiplePromiseError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultiplePromiseLateError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultiplePromiseWithArg": Object {
      "type": "async",
      "value": 45,
    },
    "callAsyncMultiplePromiseWithArgCalled1": 42,
    "callAsyncMultiplePromiseWithArgCalled2": 43,
    "callAsyncMultiplePromiseWithArgFirstReturn": Object {
      "type": "async",
      "value": 43,
    },
    "callAsyncMultiplePromiseWithArgFirstReturnCalled1": 42,
    "callAsyncMultiplePromiseWithArgFirstReturnCalled2": 43,
    "callAsyncMultiplePromiseWithArgLastReturn": Object {
      "type": "async",
      "value": 44,
    },
    "callAsyncMultiplePromiseWithArgLastReturnCalled1": 42,
    "callAsyncMultiplePromiseWithArgLastReturnCalled2": 42,
    "callAsyncMultiplePromiseWithArgNoReturn": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncMultiplePromiseWithArgNoReturnCalled1": 42,
    "callAsyncMultiplePromiseWithArgNoReturnCalled2": 42,
    "callAsyncMultipleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncLastReturn": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncNoReturn": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncWithArg": Object {
      "type": "async",
      "value": 45,
    },
    "callAsyncMultipleSyncWithArgCalled1": 42,
    "callAsyncMultipleSyncWithArgCalled2": 43,
    "callAsyncMultipleSyncWithArgFirstReturn": Object {
      "type": "async",
      "value": 43,
    },
    "callAsyncMultipleSyncWithArgFirstReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgFirstReturnCalled2": 43,
    "callAsyncMultipleSyncWithArgLastReturn": Object {
      "type": "async",
      "value": 44,
    },
    "callAsyncMultipleSyncWithArgLastReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgLastReturnCalled2": 42,
    "callAsyncMultipleSyncWithArgNoReturn": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncMultipleSyncWithArgNoReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgNoReturnCalled2": 42,
    "callAsyncNone": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncNoneWithArg": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncSingleAsyncWithArg": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncSingleAsyncWithArgCalled1": 42,
    "callAsyncSinglePromiseWithArg": Object {
      "type": "async",
      "value": 43,
    },
    "callAsyncSinglePromiseWithArgCalled1": 42,
    "callAsyncSingleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncSingleSyncWithArg": Object {
      "type": "async",
      "value": 43,
    },
    "callAsyncSingleSyncWithArgCalled1": 42,
    "callAsyncSingleSyncWithArgNoReturn": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncSingleSyncWithArgNoReturnCalled1": 42,
    "promiseMultipleAsyncEarlyError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleAsyncError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleAsyncLateError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleAsyncLateErrorEarlyResult1": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleAsyncLateErrorEarlyResult2": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleAsyncWithArg": Object {
      "type": "promise",
      "value": 45,
    },
    "promiseMultipleAsyncWithArgCalled1": 42,
    "promiseMultipleAsyncWithArgCalled2": 43,
    "promiseMultipleAsyncWithArgFirstReturn": Object {
      "type": "promise",
      "value": 43,
    },
    "promiseMultipleAsyncWithArgFirstReturnCalled1": 42,
    "promiseMultipleAsyncWithArgFirstReturnCalled2": 43,
    "promiseMultipleAsyncWithArgLastReturn": Object {
      "type": "promise",
      "value": 44,
    },
    "promiseMultipleAsyncWithArgLastReturnCalled1": 42,
    "promiseMultipleAsyncWithArgLastReturnCalled2": 42,
    "promiseMultipleAsyncWithArgNoReturn": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseMultipleAsyncWithArgNoReturnCalled1": 42,
    "promiseMultipleAsyncWithArgNoReturnCalled2": 42,
    "promiseMultipleMixed1WithArg": Object {
      "type": "promise",
      "value": 48,
    },
    "promiseMultipleMixed1WithArgCalled1": 42,
    "promiseMultipleMixed1WithArgCalled2": 43,
    "promiseMultipleMixed1WithArgCalled3": 45,
    "promiseMultipleMixed2WithArg": Object {
      "type": "promise",
      "value": 45,
    },
    "promiseMultipleMixed2WithArgCalled1": 42,
    "promiseMultipleMixed2WithArgCalled2": 43,
    "promiseMultipleMixed3WithArg": Object {
      "type": "promise",
      "value": 48,
    },
    "promiseMultipleMixed3WithArgCalled1": 42,
    "promiseMultipleMixed3WithArgCalled2": 43,
    "promiseMultipleMixed3WithArgCalled3": 45,
    "promiseMultipleMixedError1WithArg": Object {
      "error": "Error in sync",
      "type": "promise",
    },
    "promiseMultipleMixedError1WithArgCalled1": 42,
    "promiseMultipleMixedError1WithArgCalled2": 42,
    "promiseMultipleMixedError1WithArgCalled3": 43,
    "promiseMultipleMixedError2WithArg": Object {
      "error": "Error in promise",
      "type": "promise",
    },
    "promiseMultipleMixedError2WithArgCalled1": 42,
    "promiseMultipleMixedError2WithArgCalled2": 42,
    "promiseMultipleMixedError3WithArg": Object {
      "error": "Error in async",
      "type": "promise",
    },
    "promiseMultipleMixedError3WithArgCalled1": 42,
    "promiseMultipleMixedLateError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultiplePromiseEarlyError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultiplePromiseError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultiplePromiseLateError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultiplePromiseWithArg": Object {
      "type": "promise",
      "value": 45,
    },
    "promiseMultiplePromiseWithArgCalled1": 42,
    "promiseMultiplePromiseWithArgCalled2": 43,
    "promiseMultiplePromiseWithArgFirstReturn": Object {
      "type": "promise",
      "value": 43,
    },
    "promiseMultiplePromiseWithArgFirstReturnCalled1": 42,
    "promiseMultiplePromiseWithArgFirstReturnCalled2": 43,
    "promiseMultiplePromiseWithArgLastReturn": Object {
      "type": "promise",
      "value": 44,
    },
    "promiseMultiplePromiseWithArgLastReturnCalled1": 42,
    "promiseMultiplePromiseWithArgLastReturnCalled2": 42,
    "promiseMultiplePromiseWithArgNoReturn": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseMultiplePromiseWithArgNoReturnCalled1": 42,
    "promiseMultiplePromiseWithArgNoReturnCalled2": 42,
    "promiseMultipleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncLastReturn": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncNoReturn": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncWithArg": Object {
      "type": "promise",
      "value": 45,
    },
    "promiseMultipleSyncWithArgCalled1": 42,
    "promiseMultipleSyncWithArgCalled2": 43,
    "promiseMultipleSyncWithArgFirstReturn": Object {
      "type": "promise",
      "value": 43,
    },
    "promiseMultipleSyncWithArgFirstReturnCalled1": 42,
    "promiseMultipleSyncWithArgFirstReturnCalled2": 43,
    "promiseMultipleSyncWithArgLastReturn": Object {
      "type": "promise",
      "value": 44,
    },
    "promiseMultipleSyncWithArgLastReturnCalled1": 42,
    "promiseMultipleSyncWithArgLastReturnCalled2": 42,
    "promiseMultipleSyncWithArgNoReturn": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseMultipleSyncWithArgNoReturnCalled1": 42,
    "promiseMultipleSyncWithArgNoReturnCalled2": 42,
    "promiseNone": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseNoneWithArg": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseSingleAsyncWithArg": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseSingleAsyncWithArgCalled1": 42,
    "promiseSinglePromiseWithArg": Object {
      "type": "promise",
      "value": 43,
    },
    "promiseSinglePromiseWithArgCalled1": 42,
    "promiseSingleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseSingleSyncWithArg": Object {
      "type": "promise",
      "value": 43,
    },
    "promiseSingleSyncWithArgCalled1": 42,
    "promiseSingleSyncWithArgNoReturn": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseSingleSyncWithArgNoReturnCalled1": 42,
  },
  "intercept": Object {
    "callAsyncContextIntercepted": Object {
      "type": "async",
      "value": 48,
    },
    "callAsyncContextInterceptedCall1": Array [
      Object {
        "number": 42,
      },
      1,
      2,
      3,
    ],
    "callAsyncContextInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "callAsyncContextInterceptedTap1": Object {
      "number": 42,
    },
    "callAsyncIntercepted": Object {
      "type": "async",
      "value": 9,
    },
    "callAsyncInterceptedCall1": Array [
      1,
      2,
      3,
    ],
    "callAsyncInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "callAsyncInterceptedTap1": Object {
      "fn": 2,
      "name": "promise",
      "type": "promise",
    },
    "callAsyncInterceptedTap2": Object {
      "fn": 3,
      "name": "sync",
      "type": "sync",
    },
    "callAsyncUnusedContextIntercepted": Object {
      "type": "async",
      "value": 6,
    },
    "callAsyncUnusedContextInterceptedCall1": Array [
      undefined,
      1,
      2,
      3,
    ],
    "callAsyncUnusedContextInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "callAsyncUnusedContextInterceptedTap1": undefined,
    "promiseContextIntercepted": Object {
      "type": "promise",
      "value": 48,
    },
    "promiseContextInterceptedCall1": Array [
      Object {
        "number": 42,
      },
      1,
      2,
      3,
    ],
    "promiseContextInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "promiseContextInterceptedTap1": Object {
      "number": 42,
    },
    "promiseIntercepted": Object {
      "type": "promise",
      "value": 9,
    },
    "promiseInterceptedCall1": Array [
      1,
      2,
      3,
    ],
    "promiseInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "promiseInterceptedTap1": Object {
      "fn": 2,
      "name": "promise",
      "type": "promise",
    },
    "promiseInterceptedTap2": Object {
      "fn": 3,
      "name": "sync",
      "type": "sync",
    },
    "promiseUnusedContextIntercepted": Object {
      "type": "promise",
      "value": 6,
    },
    "promiseUnusedContextInterceptedCall1": Array [
      undefined,
      1,
      2,
      3,
    ],
    "promiseUnusedContextInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "promiseUnusedContextInterceptedTap1": undefined,
  },
  "sync": Object {
    "callAsyncIntercepted": Object {
      "type": "async",
      "value": 9,
    },
    "callAsyncInterceptedCall1": Array [
      1,
      2,
      3,
    ],
    "callAsyncInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "callAsyncInterceptedTap1": Object {
      "fn": 2,
      "name": "sync2",
      "type": "sync",
    },
    "callAsyncInterceptedTap2": Object {
      "fn": 3,
      "name": "sync1",
      "type": "sync",
    },
    "callAsyncMultipleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncMultipleSyncWithArg": Object {
      "type": "async",
      "value": 127,
    },
    "callAsyncMultipleSyncWithArgCalled1": 42,
    "callAsyncMultipleSyncWithArgCalled2": 84,
    "callAsyncMultipleSyncWithArgFirstReturn": Object {
      "type": "async",
      "value": 84,
    },
    "callAsyncMultipleSyncWithArgFirstReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgFirstReturnCalled2": 84,
    "callAsyncMultipleSyncWithArgLastReturn": Object {
      "type": "async",
      "value": 85,
    },
    "callAsyncMultipleSyncWithArgLastReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgLastReturnCalled2": 42,
    "callAsyncMultipleSyncWithArgNoReturn": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncMultipleSyncWithArgNoReturnCalled1": 42,
    "callAsyncMultipleSyncWithArgNoReturnCalled2": 42,
    "callAsyncMultipleSyncWithArgs": Object {
      "type": "async",
      "value": 217,
    },
    "callAsyncMultipleSyncWithArgsCalled1": Array [
      42,
      43,
      44,
    ],
    "callAsyncMultipleSyncWithArgsCalled2": Array [
      129,
      43,
      44,
    ],
    "callAsyncNone": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncNoneWithArg": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncSingleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "callAsyncSingleSyncWithArg": Object {
      "type": "async",
      "value": 42,
    },
    "callAsyncSingleSyncWithArgCalled": 42,
    "promiseIntercepted": Object {
      "type": "promise",
      "value": 9,
    },
    "promiseInterceptedCall1": Array [
      1,
      2,
      3,
    ],
    "promiseInterceptedCall2": Array [
      1,
      2,
      3,
    ],
    "promiseInterceptedTap1": Object {
      "fn": 2,
      "name": "sync2",
      "type": "sync",
    },
    "promiseInterceptedTap2": Object {
      "fn": 3,
      "name": "sync1",
      "type": "sync",
    },
    "promiseMultipleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncError": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseMultipleSyncWithArg": Object {
      "type": "promise",
      "value": 127,
    },
    "promiseMultipleSyncWithArgCalled1": 42,
    "promiseMultipleSyncWithArgCalled2": 84,
    "promiseMultipleSyncWithArgFirstReturn": Object {
      "type": "promise",
      "value": 84,
    },
    "promiseMultipleSyncWithArgFirstReturnCalled1": 42,
    "promiseMultipleSyncWithArgFirstReturnCalled2": 84,
    "promiseMultipleSyncWithArgLastReturn": Object {
      "type": "promise",
      "value": 85,
    },
    "promiseMultipleSyncWithArgLastReturnCalled1": 42,
    "promiseMultipleSyncWithArgLastReturnCalled2": 42,
    "promiseMultipleSyncWithArgNoReturn": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseMultipleSyncWithArgNoReturnCalled1": 42,
    "promiseMultipleSyncWithArgNoReturnCalled2": 42,
    "promiseMultipleSyncWithArgs": Object {
      "type": "promise",
      "value": 217,
    },
    "promiseMultipleSyncWithArgsCalled1": Array [
      42,
      43,
      44,
    ],
    "promiseMultipleSyncWithArgsCalled2": Array [
      129,
      43,
      44,
    ],
    "promiseNone": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseNoneWithArg": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseSingleSync": Object {
      "error": "Waterfall hooks must have at least one argument",
    },
    "promiseSingleSyncWithArg": Object {
      "type": "promise",
      "value": 42,
    },
    "promiseSingleSyncWithArgCalled": 42,
  },
}
`;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       that caused the warning.
     */
    node: Node;
    /**
     * The line in the input file with this warning's source.
     */
    line: number;
    /**
     * Column in the input file with this warning's source.
     */
    column: number;
  }
  interface WarningOptions extends ResultOptions {
    /**
     * A word inside a node's string that should be highlighted as source
     * of warning.
     */
    word?: string;
    /**
     * The index inside a node's string that should be highlighted as
     * source of warning.
     */
    index?: number;
  }
  /**
   * The CSS parser throws this error for broken CSS.
   */
  interface CssSyntaxError extends InputOrigin {
    name: string;
    /**
     * @returns Error position, message and source code of broken part.
     */
    toString(): string;
    /**
     * @param color Whether arrow should be colored red by terminal color codes.
     * By default, PostCSS will use process.stdout.isTTY and
     * process.env.NODE_DISABLE_COLORS.
     * @returns A few lines of CSS source that caused the error. If CSS has
     * input source map without sourceContent this method will return an empty
     * string.
     */
    showSourceCode(color?: boolean): string;
    /**
     * Contains full error text in the GNU error format.
     */
    message: string;
    /**
     * Contains only the error description.
     */
    reason: string;
    /**
     * Contains the PostCSS plugin name if the error didn't come from the
     * CSS parser.
     */
    plugin?: string;
    input?: InputOrigin;
  }
  interface InputOrigin {
    /**
     * If parser's from option is set, contains the absolute path to the
     * broken file. PostCSS will use the input source map to detect the
     * original error location. If you wrote a Sass file, then compiled it
     * to CSS and parsed it with PostCSS, PostCSS will show the original
     * position in the Sass file. If you need the position in the PostCSS
     * input (e.g., to debug the previous compiler), use error.input.file.
     */
    file?: string;
    /**
     * Contains the source line of the error. PostCSS will use the input
     * source map to detect the original error location. If you wrote a Sass
     * file, then compiled it to CSS and parsed it with PostCSS, PostCSS
     * will show the original position in the Sass file. If you need the
     * position in the PostCSS input (e.g., to debug the previous
     * compiler), use error.input.line.
     */
    line?: number;
    /**
     * Contains the source column of the error. PostCSS will use input
     * source map to detect the original error location. If you wrote a
     * Sass file, then compiled it to CSS and parsed it with PostCSS,
     * PostCSS will show the original position in the Sass file. If you
     * need the position in the PostCSS input (e.g., to debug the
     * previous compiler), use error.input.column.
     */
    column?: number;
    /**
     * Contains the source code of the broken file. PostCSS will use the
     * input source map to detect the original error location. If you wrote
     * a Sass file, then compiled it to CSS and parsed it with PostCSS,
     * PostCSS will show the original position in the Sass file. If you need
     * the position in the PostCSS input (e.g., to debug the previous
     * compiler), use error.input.source.
     */
    source?: string;
  }
  export class PreviousMap {
    private inline;
    annotation: string;
    root: string;
    private consumerCache;
    text: string;
    file: string;
    constructor(css: any, opts: any);
    consumer(): mozilla.SourceMapConsumer;
    withContent(): boolean;
    startWith(string: string, start: string): boolean;
    loadAnnotation(css: string): void;
    decodeInline(text: string): string;
    loadMap(
      file: any,
      prev: string | Function | mozilla.SourceMapConsumer | mozilla.SourceMapGenerator | mozilla.RawSourceMap
    ): string;
    isMap(map: any): boolean;
  }
  /**
   * Represents the source CSS.
   */
  interface Input {
    /**
     * The absolute path to the CSS source file defined with the "from" option.
     * Either this property or the "id" property are always defined.
     */
    file?: string;
    /**
     * The unique ID of the CSS source. Used if "from" option is not provided
     * (because PostCSS does not know the file path). Either this property
     * or the "file" property are always defined.
     */
    id?: string;
    /**
     * The CSS source identifier. Contains input.file if the user set the
     * "from" option, or input.id if they did not.
     */
    from: string;
    /**
     * Represents the input source map passed from a compilation step before
     * PostCSS (e.g., from the Sass compiler).
     */
    map: PreviousMap;
    /**
     * The flag to indicate whether or not the source code has Unicode BOM.
     */
    hasBOM: boolean;
    /**
     * Reads the input source map.
     * @returns A symbol position in the input source (e.g., in a Sass file
     * that was compiled to CSS before being passed to PostCSS):
     */
    origin(line: number, column: number): InputOrigin;
  }
  type ChildNode = AtRule | Rule | Declaration | Comment;
  type Node = Root | ChildNode;
  interface NodeBase {
    /**
     * Returns the input source of the node. The property is used in source
     * map generation. If you create a node manually
     * (e.g., with postcss.decl() ), that node will not have a source
     * property and will be absent from the source map. For this reason, the
     * plugin developer should consider cloning nodes to create new ones
     * (in which case the new node's source will reference the original,
     * cloned node) or setting the source property manually.
     */
    source?: NodeSource;
    /**
     * Contains information to generate byte-to-byte equal node string as it
     * was in origin input.
     */
    raws: NodeRaws;
    /**
     * @returns A CSS string representing the node.
     */
    toString(): string;
    /**
     * This method produces very useful error messages. If present, an input
     * source map will be used to get the original position of the source, even
     * from a previous compilation step (e.g., from Sass compilation).
     * @returns The original position of the node in the source, showing line
     * and column numbers and also a small excerpt to facilitate debugging.
     */
    error(
      /**
       * Error description.
       */
      message: string, options?: NodeErrorOptions): CssSyntaxError;
    /**
     * Creates an instance of Warning and adds it to messages. This method is
     * provided as a convenience wrapper for Result#warn.
     * Note that `opts.node` is automatically passed to Result#warn for you.
     * @param result The result that will receive the warning.
     * @param text Warning message. It will be used in the `text` property of
     * the message object.
     * @param opts Properties to assign to the message object.
     */
    warn(result: Result, text: string, opts?: WarningOptions): void;
    /**
     * @returns The next child of the node's parent; or, returns undefined if
     * the current node is the last child.
     */
    next(): ChildNode | void;
    /**
     * @returns The previous child of the node's parent; or, returns undefined
     * if the current node is the first child.
     */
    prev(): ChildNode | void;
  	/**
  	 * Insert new node before current node to current node’s parent.
  	 *
  	 * Just an alias for `node.parent.insertBefore(node, newNode)`.
  	 *
  	 * @returns this node for method chaining.
  	 *
  	 * @example
  	 * decl.before('content: ""');
  	 */
    before(newNode: Node | object | string | Node[]): this;
		/**
		 * Insert new node after current node to current node’s parent.
		 *
		 * Just an alias for `node.parent.insertAfter(node, newNode)`.
		 *
		 * @returns this node for method chaining.
		 *
		 * @example
		 * decl.after('color: black');
		 */
    after(newNode: Node | object | string | Node[]): this;
    /**
     * @returns The Root instance of the node's tree.
     */
    root(): Root;
    /**
     * Removes the node from its parent and cleans the parent property in the
     * node and its children.
     * @returns This node for chaining.
     */
    remove(): this;
    /**
     * Inserts node(s) before the current node and removes the current node.
     * @returns This node for chaining.
     */
    replaceWith(...nodes: (Node | object)[]): this;
    /**
     * @param overrides New properties to override in the clone.
     * @returns A clone of this node. The node and its (cloned) children will
     * have a clean parent and code style properties.
     */
    clone(overrides?: object): this;
    /**
     * Shortcut to clone the node and insert the resulting cloned node before
     * the current node.
     * @param overrides New Properties to override in the clone.
     * @returns The cloned node.
     */
    cloneBefore(overrides?: object): this;
    /**
     * Shortcut to clone the node and insert the resulting cloned node after
     * the current node.
     * @param overrides New Properties to override in the clone.
     * @returns The cloned node.
     */
    cloneAfter(overrides?: object): this;
    /**
     * @param prop Name or code style property.
     * @param defaultType Name of default value. It can be easily missed if the
     * value is the same as prop.
     * @returns A code style property value. If the node is missing the code
     * style property (because the node was manually built or cloned), PostCSS
     * will try to autodetect the code style property by looking at other nodes
     * in the tree.
     */
    raw(prop: string, defaultType?: string): any;
  }
  interface NodeNewProps {
    source?: NodeSource;
    raws?: NodeRaws;
  }
  interface NodeRaws {
    /**
     * The space symbols before the node. It also stores `*` and `_`
     * symbols before the declaration (IE hack).
     */
    before?: string;
    /**
     * The space symbols after the last child of the node to the end of
     * the node.
     */
    after?: string;
    /**
     * The symbols between the property and value for declarations,
     * selector and "{" for rules, last parameter and "{" for at-rules.
     */
    between?: string;
    /**
     * True if last child has (optional) semicolon.
     */
    semicolon?: boolean;
    /**
     * The space between the at-rule's name and parameters.
     */
    afterName?: string;
    /**
     * The space symbols between "/*" and comment's text.
     */
    left?: string;
    /**
     * The space symbols between comment's text and "*\/".
     */
    right?: string;
    /**
     * The content of important statement, if it is not just "!important".
     */
    important?: string;
  }
  interface NodeSource {
    input: Input;
    /**
     * The starting position of the node's source.
     */
    start?: {
      column: number;
      line: number;
    };
    /**
     * The ending position of the node's source.
     */
    end?: {
      column: number;
      line: number;
    };
  }
  interface NodeErrorOptions {
    /**
     * Plugin name that created this error. PostCSS will set it automatically.
     */
    plugin?: string;
    /**
     * A word inside a node's string, that should be highlighted as source
     * of error.
     */
    word?: string;
    /**
     * An index inside a node's string that should be highlighted as source
     * of error.
     */
    index?: number;
  }
  interface JsonNode {
    /**
     * Returns a string representing the node's type. Possible values are
     * root, atrule, rule, decl or comment.
     */
    type?: string;
    /**
     * Returns the node's parent node.
     */
    parent?: JsonContainer;
    /**
     * Returns the input source of the node. The property is used in source
     * map generation. If you create a node manually (e.g., with
     * postcss.decl() ), that node will not have a  source  property and
     * will be absent from the source map. For this reason, the plugin
     * developer should consider cloning nodes to create new ones (in which
     * case the new node's source will reference the original, cloned node)
     * or setting the source property manually.
     */
    source?: NodeSource;
    /**
     * Contains information to generate byte-to-byte equal node string as it
     * was in origin input.
     */
    raws?: NodeRaws;
  }
  type Container = Root | AtRule | Rule;
  /**
   * Containers can store any content. If you write a rule inside a rule,
   * PostCSS will parse it.
   */
  interface ContainerBase extends NodeBase {
    /**
     * Contains the container's children.
     */
    nodes?: ChildNode[];
    /**
     * @returns The container's first child.
     */
    first?: ChildNode;
    /**
     * @returns The container's last child.
     */
    last?: ChildNode;
    /**
     * @param overrides New properties to override in the clone.
     * @returns A clone of this node. The node and its (cloned) children will
     * have a clean parent and code style properties.
     */
    clone(overrides?: object): this;
    /**
     * @param child Child of the current container.
     * @returns The child's index within the container's "nodes" array.
     */
    index(child: ChildNode | number): number;
    /**
     * Determines whether all child nodes satisfy the specified test.
     * @param callback A function that accepts up to three arguments. The
     * every method calls the callback function for each node until the
     * callback returns false, or until the end of the array.
     * @returns True if the callback returns true for all of the container's
     * children.
     */
    every(callback: (node: ChildNode, index: number, nodes: ChildNode[]) => any, thisArg?: any): boolean;
    /**
     * Determines whether the specified callback returns true for any child node.
     * @param callback A function that accepts up to three arguments. The some
     * method calls the callback for each node until the callback returns true,
     * or until the end of the array.
     * @param thisArg An object to which the this keyword can refer in the
     * callback function. If thisArg is omitted, undefined is used as the
     * this value.
     * @returns True if callback returns true for (at least) one of the
     * container's children.
     */
    some(callback: (node: ChildNode, index: number, nodes: ChildNode[]) => boolean, thisArg?: any): boolean;
    /**
     * Iterates through the container's immediate children, calling the
     * callback function for each child. If you need to recursively iterate
     * through all the container's descendant nodes, use container.walk().
     * Unlike the for {} -cycle or Array#forEach() this iterator is safe if
     * you are mutating the array of child nodes during iteration.
     * @param callback Iterator. Returning false will break iteration. Safe
     * if you are mutating the array of child nodes during iteration. PostCSS
     * will adjust the current index to match the mutations.
     * @returns False if the callback returns false during iteration.
     */
    each(callback: (node: ChildNode, index: number) => any): boolean | void;
    /**
     * Traverses the container's descendant nodes, calling `callback` for each
     * node. Like container.each(), this method is safe to use if you are
     * mutating arrays during iteration. If you only need to iterate through
     * the container's immediate children, use container.each().
     * @param callback Iterator.
     */
    walk(callback: (node: ChildNode, index: number) => any): boolean | void;
    /**
     * Traverses the container's descendant nodes, calling `callback` for each
     * declaration. Like container.each(), this method is safe to use if you
     * are mutating arrays during iteration.
     * @param propFilter Filters declarations by property name. Only those
     * declarations whose property matches propFilter will be iterated over.
     * @param callback Called for each declaration node within the container.
     */
    walkDecls(propFilter: string | RegExp, callback?: (decl: Declaration, index: number) => any): boolean | void;
    walkDecls(callback: (decl: Declaration, index: number) => any): boolean | void;
    /**
     * Traverses the container's descendant nodes, calling `callback` for each
     * at-rule. Like container.each(), this method is safe to use if you are
     * mutating arrays during iteration.
     * @param nameFilter Filters at-rules by name. If provided, iteration
     * will only happen over at-rules that have matching names.
     * @param callback Iterator called for each at-rule node within the
     * container.
     */
    walkAtRules(nameFilter: string | RegExp, callback: (atRule: AtRule, index: number) => any): boolean | void;
    walkAtRules(callback: (atRule: AtRule, index: number) => any): boolean | void;
    /**
     * Traverses the container's descendant nodes, calling `callback` for each
     * rule. Like container.each(), this method is safe to use if you are
     * mutating arrays during iteration.
     * @param selectorFilter Filters rules by selector. If provided,
     * iteration will only happen over rules that have matching names.
     * @param callback Iterator called for each rule node within the
     * container.
     */
    walkRules(selectorFilter: string | RegExp, callback: (atRule: Rule, index: number) => any): boolean | void;
    walkRules(callback: (atRule: Rule, index: number) => any): boolean | void;
    walkRules(selectorFilter: any, callback?: (atRule: Rule, index: number) => any): boolean | void;
    /**
     * Traverses the container's descendant nodes, calling `callback` for each
     * comment. Like container.each(), this method is safe to use if you are
     * mutating arrays during iteration.
     * @param callback Iterator called for each comment node within the container.
     */
    walkComments(callback: (comment: Comment, indexed: number) => any): void | boolean;
    /**
     * Passes all declaration values within the container that match pattern
     * through the callback, replacing those values with the returned result of
     * callback. This method is useful if you are using a custom unit or
     * function and need to iterate through all values.
     * @param pattern Pattern that we need to replace.
     * @param options Options to speed up the search.
     * @param callbackOrReplaceValue String to replace pattern or callback
     * that will return a new value. The callback will receive the same
     * arguments as those passed to a function parameter of String#replace.
     */
    replaceValues(pattern: string | RegExp, options: {
        /**
         * Property names. The method will only search for values that match
         * regexp  within declarations of listed properties.
         */
        props?: string[];